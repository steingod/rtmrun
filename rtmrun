#!/usr/bin/perl -w
#
# NAME:
# To perform RTM simulations for clear sky conditions on a full day using
# libRadtran.
# It should be possible to perform a time series for a full year on a
# specified station as well.
#
# PURPOSE:
# NA
#
# REQUIREMENTS:
# NA
#
# INPUT:
# NA
#
# OUTPUT:
# NA
#
# NOTES:
# 1 Dobson Unit for Ozone is 0.001 atm-cm
#
# BUGS:
# NA
#
# AUTHOR:
# Øystein Godøy, METNO/FOU, 16.11.2010 
#
# MODIFIED:
# NA
#
# CVS_ID:
# $Id: rtmrun,v 1.2 2012-09-04 15:11:57 steingod Exp $
#
#

use strict;
use Cwd;
use Date::Calc qw(Parse_Date Decode_Date_EU);
#use Date::Manip qw(ParseDate);
use Date::Manip;
use Getopt::Std;

use vars qw($opt_h $opt_c);

sub usage;
sub decode_cfg;

my $verbose = 0;
my $outfile = "libradtran_simulation.txt";
my $tmpfile = "tmpfile.txt";
my $errfile = "errfile.txt";
my $srcdir = "/disk1/software/libRadtran-1.4";
my $uvspec="$srcdir"."/bin/uvspec";
my $zenith="$srcdir"."/bin/zenith -q -t0";
my %position = (
    lat => 60.4,
    lon => -5.32, # positive westwards for libRadtran
);
my %myperiod = (
    startdate => '', # ISO8601
    enddate => '', # ISO8601
    step => 0, # minutes
);
my %mydate = (
    year => 2011,
    month => 5,
    mday => 13,
    shour => 0,
    ehour => 23,
    step => 1,
);
my %cfg = (
atmosphere_file => "$srcdir/data/atmmod/afglms.dat", # Location of atmospheric profile file. 
solar_file => "$srcdir/data/solar_flux/atlas_plus_modtran", # Location of the extraterrestrial spectrum
albedo => 0.05, # Surface albedo
rte_solver => "disort", # Radiative transfer equation solver
deltam => "on", # delta-M scaling on
nstr=> 6, # Number of streams
wavelength => "300.0 3000.0", # Wavelength range [nm]
correlated_k => "kato2",
output => "sum",
output_user => "sza eglo",
dens_column => "O3 300 DU",
h2o_precip => "29.3",
);

usage if !getopts("hc:");
usage if ($opt_h || !$opt_c);
my $cfgfile = $opt_c;

# Decode configuration file
die "Failed to decode configuration file...\n" 
unless (decode_cfg(\%position, \%myperiod));

print("Latitude: $position{lat}\n");
print("Longitude: $position{lon}\n");

print("startdate: $myperiod{startdate}\n");
print("enddate: $myperiod{enddate}\n");
print("timestep: $myperiod{step}\n");

##my ($year,$month,$day) = Decode_Date_EU($myperiod{startdate}); 
##print("$year-$month-$day\n");
##exit;
my $doy=0;
#$doy = Date_DayOfYear($mydate);
#print(">> $mydate[0]-$mydate[1]-$mydate[2] is $doy \n");
my $mydate = ParseDate($myperiod{enddate});
my $year = UnixDate($mydate,"%Y");
my $month = UnixDate($mydate,"%m");
my $mday = UnixDate($mydate,"%d");
$doy = Date_DayOfYear($month,$mday,$year);
print(">> $mydate is $doy \n");
print("$year-$month-$mday\n");

#print("I dag: ".ParseDate("now")."\n");
my $tz = Date_TimeZone;
print("Timezone: $tz\n");

my $newdate = DateCalc($mydate,$myperiod{step});
print("$newdate\n");

exit; # while testing...

my($myhour, $sza, $tmp, $key, $value, $cwd, $ssi, $doy);

$doy = Date_DayOfYear($mydate{'month'},$mydate{'mday'},$mydate{'year'});

$cwd = getcwd();
chdir "$srcdir"."/bin";

open FP1, ">$cwd/$outfile" or die "Can't open $cwd/$outfile";

for ($myhour = $mydate{'shour'}; $myhour <= $mydate{'ehour'}; $myhour++) {
    $tmp = qx/$zenith -a $position{'lat'} -o $position{'lon'} -y$mydate{'year'} $mydate{'mday'} $mydate{'month'} $myhour 0 0/;
    $sza = (split / +/,$tmp)[1];

    $cfgfile = "";
    while (($key, $value) = each %cfg) {
        $cfgfile .= "$key $value\n";
    }
    $cfgfile .= "sza $sza\n";
    $cfgfile .= "day_of_year $doy\n";
    $cfgfile .= "quiet\n";

    open FP2, ">$tmpfile.txt" or die "Can't open $tmpfile\n";
    print FP2 "$cfgfile";
    close FP2;

    if ($verbose) {
        $tmp = qx/$uvspec < $tmpfile.txt/;
    } else {
        $tmp = qx/$uvspec < $tmpfile.txt 2>$errfile/;
        unlink "$tmpfile";
    }
    $ssi = (split / +/,$tmp)[2];

    printf FP1 "%02d %6.2f %6.2f\n",$myhour,$sza,$ssi;
};
close FP1;
chdir $cwd;

exit;

###########################################################

sub usage {
    print("$0 [-h] -c <file>\n");
    print("\t-h: print this\n");
    print("\t-c: configuration file\n");
    exit;
}

sub decode_cfg {

    my $posref = shift @_;
    my $periodref = shift @_;

    my(@fc, $record, $keyw, $value);

    open FP, "<$cfgfile";
    @fc = <FP>;
    close FP;

    foreach $record (@fc) {
        next if ($record =~ m/^#/);
        next if ($record =~ m/^\s/);
        ($keyw, $value) = split(/=>/,$record, 2);
        $value =~ s/^\s+//;
        $value =~ s/\n$//;
        $value =~ s/#(.+)$//;
        #print("[$keyw] - [$value]\n");
        # Get location
        $posref->{lat} = $value if ($keyw =~ m/latitude/);
        $posref->{lon} = $value if ($keyw =~ m/longitude/);
        # Get period specification
        $periodref->{startdate} = $value if ($keyw =~ m/startdate/);
        $periodref->{enddate} = $value if ($keyw =~ m/enddate/);
        $periodref->{step} = $value if ($keyw =~ m/timestep/);
    }

    return(1);
}
