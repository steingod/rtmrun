#!/usr/bin/perl -w
#
# NAME:
# To perform RTM simulations for clear sky conditions on a full day using
# libRadtran.
#
# It should be possible to perform a time series for a full year on a
# specified station as well.
#
# PURPOSE:
# NA
#
# REQUIREMENTS:
# NA
#
# INPUT:
# NA
#
# OUTPUT:
# NA
#
# NOTES:
# 1 Dobson Unit for Ozone is 0.001 atm-cm
#
# Currently Date::Manip is used for time handling. Timestep is handled in
# the native form of Date::Manip. Other interfaces may be examined
# later...
#
# BUGS:
# NA
#
# AUTHOR:
# Øystein Godøy, METNO/FOU, 16.11.2010 
#
# MODIFIED:
# NA
#
# CVS_ID:
# $Id: rtmrun,v 1.5 2012-09-06 09:27:49 steingod Exp $
#

use strict;
use Cwd;
#use Date::Calc qw(Parse_Date Decode_Date_EU);
#use Date::Manip qw(ParseDate);
use Date::Manip;
use Getopt::Std;

use vars qw($opt_h $opt_c);

sub usage;
sub decode_cfg;

my $verbose = 1;
my(%locations,%uvspeccfg);
my($mydate);
my($timecnt,$cfgcnt);
my($myyear,$mymon,$mymday,$myhour,$mymin,$mydoy); 
my($sza, $tmp, $key, $value, $cwd, $ssi);

my $outfile = "libradtran_simulation.txt";
my $tmpfile = "tmpfile.txt";
my $errfile = "errfile.txt";
my $srcdir = "/disk1/software/libRadtran-1.4";
my $uvspec="$srcdir"."/bin/uvspec";
my $zenith="$srcdir"."/bin/zenith -q -t0";
my %position = (
    lat => 60.4,
    lon => -5.32, # positive westwards for libRadtran
);
my %myperiod = (
    startdate => '', # ISO8601
    enddate => '', # ISO8601
    step => 0, # minutes
);
my %mydate = (
    year => 2011,
    month => 5,
    mday => 13,
    shour => 0,
    ehour => 23,
    step => 1,
);
my %cfg = (
atmosphere_file => "$srcdir/data/atmmod/afglms.dat", # Location of atmospheric profile file. 
solar_file => "$srcdir/data/solar_flux/atlas_plus_modtran", # Location of the extraterrestrial spectrum
albedo => 0.05, # Surface albedo
rte_solver => "disort", # Radiative transfer equation solver
deltam => "on", # delta-M scaling on
nstr=> 6, # Number of streams
wavelength => "300.0 3000.0", # Wavelength range [nm]
correlated_k => "kato2",
output => "sum",
output_user => "sza eglo",
dens_column => "O3 300 DU",
h2o_precip => "29.3",
);


usage if !getopts("hc:");
usage if ($opt_h || !$opt_c);
my $cfgfile = $opt_c;

# Decode configuration file
die "Failed to decode configuration file...\n" 
unless (decode_cfg(\%locations,\%uvspeccfg,\%position,\%myperiod));

print("zenith: $locations{zenith}\n");
print("uvspec: $locations{uvspec}\n");
print("atmosphere_file: $locations{atmosphere_file}\n");
print("solar_file: $locations{solar_file}\n");
print("outfile: $locations{outfile}\n");
print("tmpfile: $locations{tmpfile}\n");
print("errfile: $locations{errfile}\n");

print("Latitude: $position{lat}\n");
print("Longitude: $position{lon}\n");

print("startdate: $myperiod{startdate}\n");
print("enddate: $myperiod{enddate}\n");
print("timestep: $myperiod{step}\n");

my $doy=0;
my $mystartdate = ParseDate($myperiod{startdate});
my $myenddate = ParseDate($myperiod{enddate});
my $tz = Date_TimeZone;
print("Timezone: $tz\n");

# Generate date and time list to process
my @mydates = ParseRecur($myperiod{step},$mystartdate,$mystartdate,$myenddate);

# Do the estimates...
$cwd = getcwd();
chdir "$srcdir"."/bin";
open FP1, ">$cwd/$outfile" or die "Can't open $cwd/$outfile";
foreach $mydate (@mydates) {
    
    # Do the time preparation
    $mydoy = UnixDate($mydate,"%j");
    $myyear = UnixDate($mydate,"%Y");
    $mymon = UnixDate($mydate,"%m");
    $mymday = UnixDate($mydate,"%d");
    $myhour = UnixDate($mydate,"%H");
    $mymin = UnixDate($mydate,"%M");
    print("Now processing $mydate\n");
    print("\t$myyear-$mymon-$mymday $myhour:$mymin $mydoy\n");
    
    # Estimate solar zenith angle
    $tmp = qx/$locations{zenith} -a $position{'lat'} -o $position{'lon'} -y $myyear $mymday $mymon $myhour $mymin 0/;
    $sza = (split / +/,$tmp)[1];
    print("\t\t$sza\n");

    # Create configuration file for uvspec
    $cfgcnt = "";
    $cfgcnt .= "atmosphere_file $locations{atmosphere_file}\n";
    $cfgcnt .= "solar_file $locations{solar_file}\n";
    while (($key, $value) = each %uvspeccfg) {
        $cfgcnt .= "$key $value\n";
    }
    $cfgcnt .= "sza $sza\n";
    $cfgcnt .= "day_of_year $mydoy\n";
    $cfgcnt .= "quiet\n";

    open FP2, ">$cwd/$tmpfile" or die "Can't open $cwd/$tmpfile\n";
    print FP2 "$cfgcnt";
    close FP2;

    # Do the actual calculations and dump output after parsing
    if ($verbose) {
        $tmp = qx/$locations{uvspec} < $cwd\/$tmpfile/;
    } else {
        $tmp = qx/$locations{uvspec} < $cwd\/$tmpfile 2>$cwd\/$errfile/;
        unlink "$tmpfile";
    }
    next unless defined($ssi = (split / +/,$tmp)[2]);

    printf FP1 "%s %6.2f %6.2f\n",UnixDate($mydate,"%Y-%m-%dT%R %j"),$sza,$ssi;
};
close FP1;

chdir $cwd;

exit;

###########################################################

sub usage {
    print("$0 [-h] -c <file>\n");
    print("\t-h: print this\n");
    print("\t-c: configuration file\n");
    exit;
}

sub decode_cfg {

    my $locationsref = shift @_;
    my $uvspeccfgref = shift @_;
    my $posref = shift @_;
    my $periodref = shift @_;

    my(@fc, $record, $keyw, $value);

    open FP, "<$cfgfile";
    @fc = <FP>;
    close FP;

    foreach $record (@fc) {
        next if ($record =~ m/^#/);
        next if ($record =~ m/^\s/);
        ($keyw, $value) = split(/=>/,$record, 2);
        $value =~ s/^\s+//;
        $value =~ s/\n$//;
        $value =~ s/#(.+)$//;

        # Get locations of software, files etc
        $locationsref->{libRadtran} = $value if ($keyw =~ m/libRadtran/);
        $locationsref->{zenith} = $value if ($keyw =~ m/zenith/);
        $locationsref->{uvspec} = $value if ($keyw =~ m/uvspec/);
        $locationsref->{atmosphere_file} = $value if ($keyw =~ m/atmosphere_file/);
        $locationsref->{solar_file} = $value if ($keyw =~ m/solar_file/);
        $locationsref->{outfile} = $value if ($keyw =~ m/outfile/);
        $locationsref->{tmpfile} = $value if ($keyw =~ m/tmpfile/);
        $locationsref->{errfile} = $value if ($keyw =~ m/errfile/);

        # Get specifications for libRadtran model setup
        $uvspeccfgref->{rte_solver} = $value if ($keyw =~ m/rte_solver/);
        $uvspeccfgref->{deltam} = $value if ($keyw =~ m/deltam/);
        $uvspeccfgref->{nstr} = $value if ($keyw =~ m/nstr/);
        $uvspeccfgref->{wavelength} = $value if ($keyw =~ m/wavelength/);
        $uvspeccfgref->{correlated_k} = $value if ($keyw =~ m/correlated_k/);
        $uvspeccfgref->{output} = $value if ($keyw =~ m/output/);
        $uvspeccfgref->{output_user} = $value if ($keyw =~ m/output_user/);
        $uvspeccfgref->{albedo} = $value if ($keyw =~ m/albedo/);
        $uvspeccfgref->{dens_column} = $value if ($keyw =~ m/dens_column/);
        $uvspeccfgref->{h2o_precip} = $value if ($keyw =~ m/h2o_precip/);

        # Get location
        $posref->{lat} = $value if ($keyw =~ m/latitude/);
        $posref->{lon} = $value if ($keyw =~ m/longitude/);
        
        # Get period specification
        $periodref->{startdate} = $value if ($keyw =~ m/startdate/);
        $periodref->{enddate} = $value if ($keyw =~ m/enddate/);
        $periodref->{step} = $value if ($keyw =~ m/timestep/);
    }

    return(1);
}
